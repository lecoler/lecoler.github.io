<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[串口（com）]]></title>
    <url>%2F2021%2F01%2F18%2Fcom%2F</url>
    <content type="text"><![CDATA[串口标准地址和IRQ 标准地址和IRQ串口又称COM，COM1~COM8 COM1、COM2设有标准地址和IRQ COM IRQ I/O地址 COM1 4 0x3F8 COM2 3 0x2F8 COM3 4 0x3E8 COM4 3 0x2E8 COM5 4 0x3E0 COM6 3 0x2E0 COM7 4 0x338 COM8 3 0x238]]></content>
      <categories>
        <category>随手记</category>
      </categories>
      <tags>
        <tag>com</tag>
        <tag>serialPort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用shell脚本实现简易的oss上传]]></title>
    <url>%2F2020%2F10%2F15%2Fshell-oss%2F</url>
    <content type="text"><![CDATA[用shell写了个简易的阿里oss文件上传，源码如下 环境确保安装了以下binary： openssl base64 curl 验证是否安装，打开命令行输入以下指令 有返回相应的版本信息，即已安装 123456# opensslopenssl version# base64base64 --version#curlcurl -V 使用手册 下载脚本文件 打开脚本文件，填入相关配置信息，AccessKeyId,AccessKeySecret,BucketName... 于shell中执行./oss.sh 要上传的文件 上传到oss的位置 Tip Win下 可下载 git，使用git 的 git bash执行.sh脚本文件 源码oss.sh script12345678910111213141516171819202122232425262728293031323334353637383940414243444546#!/bin/bash# 配置*AccessKeyId=""AccessKeySecret=""BucketName=""Host="$&#123;BucketName&#125;.oss-xx-xxxx.aliyuncs.com"# 需上传的文件（绝对路径）file=$1# 需上传的key（oss上的存放路径，包含自身文件名）key=$2# 判断是否传参if [ -z "$file" ] || [ -z "$key" ]; then printf "\n%s\n\n" "帮助" printf " %-10s %-20s\n" "第一个参数" "需上传文件绝对路径" printf " %-10s %-20s\n\n" "" "如：/d/items/test/pic.jpg" printf " %-10s %-20s\n" "第二个参数" "上传到oss的存放路径（从bucket根目录→上传文件名）" printf " %-10s %-20s\n\n" "" "如：test/pic.jpg" printf "\n\n\t%s\n" "例子：./oss.sh /d/items/test/pic.jpg test/pic.jp" exit 0fiprintf "\n %s \n\n" "Start to upload files($&#123;file&#125;) to oss(/$&#123;BucketName&#125;/$&#123;key&#125;)"# 当前时间DateValue=$(env LANG=en_US.UTF-8 date -u "+%a, %d %b %Y %T GMT")# 请求数据类型ContentType="application/octet-stream"# 路径Resource="/$&#123;BucketName&#125;/$&#123;key&#125;"# 字符串StringToSign="PUT\n\n$&#123;ContentType&#125;\n$&#123;DateValue&#125;\n$&#123;Resource&#125;"# 加密Sign=$(echo -en "$&#123;StringToSign&#125;" | openssl sha1 -hmac $&#123;AccessKeySecret&#125; -binary | base64)# 开始请求Result=$(curl -i -q -X PUT -T "$&#123;file&#125;" \ -H "Host: $&#123;Host&#125;" \ -H "Date: $&#123;DateValue&#125;" \ -H "Content-Type: $&#123;ContentType&#125;" \ -H "Authorization: OSS $&#123;AccessKeyId&#125;:$&#123;Sign&#125;" \ -H "Accept: */*" \ "https://$&#123;Host&#125;/$&#123;key&#125;")echo "$&#123;Result&#125;"printf "\n %s \n" "The end!"echo "Press any key to exit!"read -rn 1exit 0]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>oss</tag>
        <tag>sh</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓阿里oss简易的文件上传]]></title>
    <url>%2F2020%2F09%2F15%2FAndroid-aliOss%2F</url>
    <content type="text"><![CDATA[记录一次使用阿里oss的文件上传功能，简易版配合okhttp3实现，没使用阿里配套的sdk 文件上传有PUT和POST，这里使用的是PUT 依赖implementation(&quot;com.squareup.okhttp3:okhttp:4.8.0&quot;) 生成GMT格式时间123456private fun getGMTDate(): String &#123; val cd = Calendar.getInstance() val sdf = SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss 'GMT'", Locale.US) sdf.timeZone = TimeZone.getTimeZone("GMT") return sdf.format(cd.time)&#125; Hmac-Sha1 加密12345678private fun sha1(string: String, key: String): ByteArray &#123; val algorithm = "HmacSHA1" val data = string.toByteArray(Charsets.UTF_8) val secretKeySpec = SecretKeySpec(key.toByteArray(Charsets.UTF_8), algorithm) val mac = Mac.getInstance(algorithm) mac.init(secretKeySpec) return mac.doFinal(data)&#125; Base64 加密123private fun base64(byteArray: ByteArray): String &#123; return Base64.getEncoder().encodeToString(byteArray)&#125; 简易的PUT 上传文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051private const val BaseUrl = "http://BucketName.oss-cn-shenzhen.aliyuncs.com"private const val BucketName = "test"private const val AccessKeyID = "*****"private const val AccessKeySecret = "*****"object Oss&#123; /** * @Description Authorization 签名 * @author lecoler * @param date:String GMT格式的时间 * @param key:String 上传Object的名称 * @return String 签名 **/ private fun sign(date: String, key: String): String &#123; val value = "PUT\n\napplication/octet-stream\n$date\n/$BucketName/$key" return base64(sha1(value, AccessKeySecret)) &#125; /** * @Description 上传文件 * @author lecoler * @param file:File 需要上传的文体 * @param key:String 上传Object的名称。 * 如果名称包含路径，例如a/b/c/b.jpg，则OSS会自动创建相应的文件夹。 **/ fun upload(file: File, key: String) &#123; val GMT = getGMTDate() val fileBody = RequestBody.create("application/octet-stream".toMediaTypeOrNull(), file) // 新建请求 val client = OkHttpClient() client.newCall( Request.Builder() .url("$BaseUrl/$key") .method("PUT", fileBody) .addHeader("Date", GMT) .addHeader("Authorization", "OSS $AccessKeyID:$&#123;sign(GMT, key)&#125;") .build() ) // 发送请求 .enqueue(object : Callback &#123; override fun onFailure(call: Call, e: IOException) &#123; Log.e("OSS","OSS PutObject 上传报错：$&#123;e.message&#125;") &#125; override fun onResponse(call: Call, response: Response) &#123; Log.i("OSS",response.toString()) &#125; &#125;) &#125;&#125; DOME12val file = File("abc.txt")Oss.upload(file,"Android/20200916/abc.txt")]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>oss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓获取所在局域网的其他设备IP]]></title>
    <url>%2F2020%2F09%2F15%2FAndroid-ipScan%2F</url>
    <content type="text"><![CDATA[记一次项目中的需求，获取安卓设备所在局域网的其他设备的IP和MAC地址通过查询资料，发现几种方式 shell 执行 ping 的形式，通了则存在设备 耗时 arp -a 查询路由表 安卓不支持此命令，只能通过查询文件代替cat proc/net/arp 不能确保最新 通过发送个udp包，再拿到最新的arp表 发通了则存在设备（不用管接收的设备是否处理udp包） 本文采用此方式实现 只需1-2秒时间，就能获取局域网设备IP和MAC地址 IP搜索123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100import java.io.BufferedReaderimport java.io.InputStreamReaderimport java.net.*import kotlin.Exceptionimport kotlin.concurrent.threadobject IpScan &#123; // 获取本机ip fun hostIp(): String &#123; var hostIp: String = "" try &#123; val nis = NetworkInterface.getNetworkInterfaces() for (ni in nis) &#123; val ias = ni.inetAddresses for (ia in ias) &#123; // 跳过 ipv6 if (ia is Inet6Address) &#123; continue &#125; if (ia.hostAddress != "127.0.0.1") &#123; hostIp = ia.hostAddress break &#125; &#125; &#125; &#125; catch (e: Exception) &#123; Log.e("IP扫描", "获取本机IP报错：$&#123;e.message.toString()&#125;") &#125; return hostIp &#125; /** * @Description 开始扫描ip 耗时大约 1s * @author lecoler * @param start:Int 开始的ip （范围：1-254） * @param end:Int 结束的ip （范围：1-254） * @param CB: (HashMap&lt;String, String&gt;) -&gt; Unit 结果回调 **/ fun start(start: Int, end: Int, CB: (HashMap&lt;String, String&gt;) -&gt; Unit) &#123; // 本机ip val hostIp = hostIp() // 取前缀 val ipPrefix = hostIp.substring(0, hostIp.lastIndexOf(".") + 1) thread &#123; try &#123; val dp = DatagramPacket(ByteArray(0), 0, 0) var socket: DatagramSocket = DatagramSocket() var position: Int = start // 发送udp包，发通则该ip 存在设备 while (position &lt;= end) &#123; dp.address = InetAddress.getByName("$ipPrefix$position") socket.send(dp) position++ // 分两段掉包，一次性发的话，达到236左右，会耗时3秒左右再往下发 if (position == start + (end-start) / 2) &#123; socket = DatagramSocket() &#125; &#125; socket.close() // 获取到arp val list = catArp() // 过滤 for(i in list)&#123; val ipSuffix = i.value.split('.').last().toInt() // 不在范围内，移除 if(ipSuffix &lt; start || ipSuffix &gt; end)&#123; list.remove(i.key) &#125; &#125; CB(list) &#125; catch (e: Exception) &#123; Log.e("IP扫描", "扫描报错：$&#123;e.message.toString()&#125;") &#125; &#125; &#125; // 读取 arp表 fun arp(): HashMap&lt;String, String&gt; &#123; val list: HashMap&lt;String, String&gt; = HashMap() try &#123; val exec = Runtime.getRuntime().exec("cat proc/net/arp") val br = BufferedReader(InputStreamReader(exec.inputStream)) do &#123; val line = br.readLine() // 过滤 if (line != null &amp;&amp; !line.contains("00:00:00:00:00:00") &amp;&amp; !line.contains("IP")) &#123; val str = line.split("\\s+".toRegex()) val ip:String = str[3] val mac = str[0] list[ip] = mac &#125; &#125; while (line != null) &#125; catch (e: Exception) &#123; Log.e("IP扫描", "读取ARP报错：$&#123;e.message.toString()&#125;") &#125; return list &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android重启App应用]]></title>
    <url>%2F2020%2F09%2F14%2FAndroid-rebootApp%2F</url>
    <content type="text"><![CDATA[最近有个需求，要求能在应用崩溃时，重启App应用特此记录下 重启AppKotlin 1234567891011121314val app = this.applicationContextval context = this.baseContextval intent = context.packageManager.getLaunchIntentForPackage(context.packageName)intent?.putExtra("REBOOT", "reboot")val pendingIntent = PendingIntent.getActivity( app, 0, intent, PendingIntent.FLAG_ONE_SHOT)val alarmManager = app.getSystemService(Context.ALARM_SERVICE) as AlarmManager// 1秒后启动alarmManager.set(AlarmManager.RTC, System.currentTimeMillis() + 1000, pendingIntent)android.os.Process.killProcess(android.os.Process.myPid()) Java 12345678910ApplicationContext app = getApplicationContext();Context context = getBaseContext();Intent intent = context.getPackageManager().getLaunchIntentForPackage(context.getPackageName());// 带参数intent.putExtra("REBOOT","reboot");PendingIntent pendingIntent = PendingIntent.getActivity(app, 0, intent, PendingIntent.FLAG_ONE_SHOT);AlarmManager alarmManager = (AlarmManager) getSystemService(Context.ALARM_SERVICE);// 1秒后启动alarmManager.set(AlarmManager.RTC, System.currentTimeMillis() + 1000, pendingIntent);android.os.Process.killProcess(android.os.Process.myPid()); 全局捕获错误基于 Thread.UncaughtExceptionHandler 类可实现捕获错误，避免App应用崩溃停止运行 例如 复写Thread.UncaughtExceptionHandler 123456789101112131415161718class CrashHandler(private val app: Context) : Thread.UncaughtExceptionHandler &#123; override fun uncaughtException(t: Thread, e: Throwable) &#123; e.printStackTrace() // 记录日志 val stackTrace = e.stackTrace val targetStackTrace: StackTraceElement? = stackTrace.first() if (targetStackTrace != null) &#123; Log.e( "程序崩溃错误", "线程：$&#123;t.name&#125;\n位置：$&#123;targetStackTrace.className&#125;.$&#123;targetStackTrace.methodName&#125;($&#123;targetStackTrace.fileName&#125;:$&#123;targetStackTrace.lineNumber&#125;)\n报错信息：$&#123;e.message ?: e.toString()&#125;" ) &#125; else &#123; Log.e("程序崩溃错误", e.message ?: "未知") &#125; &#125;&#125; 于全局里设置默认错误捕获处理 1234567class App : Application() &#123; override fun onCreate() &#123; super.onCreate() // 设置全局错误捕获拦截 Thread.setDefaultUncaughtExceptionHandler(CrashHandler(applicationContext)) &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css垂直水平居住实现方法]]></title>
    <url>%2F2020%2F06%2F22%2Fcss%E5%9E%82%E7%9B%B4%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[css实现垂直水平都居中的方法汇总，都是自己亲手实践过的 方法一（height、line-height、text-align）使用height、line-height 设置相同值，配和text-align设置居中 12345678910111213141516171819202122232425262728.box&#123; height: 100px; line-height: 100px; text-align: center;&#125;``` **缺点：固定高度，无法实现两行文本的居中**### 方法二（position、margin：负值）父元素设置`position: relative`，使用`position: absolute`，配合margin负值食用。```css.box&#123; width: 100px; height: 100px; position:absolute; top: 50%; left: 50%; margin-top: -50px; margin-left: -50px;&#125;/*简化*/.box&#123; width: 100px; height: 100px; position:absolute; top: calc(50% - 50px); left: calc(50% - 50px);&#125; 缺点：需配合父元素食用，固定高度，高度无法自适应内容。元素脱离文档流 方法三（position、margin：auto）父元素设置position: relative，使用position: absolute，配合margin: auto食用。 12345678.box&#123; position:absolute; top: 0; right: 0; bottom: 0; left: 0; margin: auto;&#125; 缺点：需配合父元素食用，元素脱离文档流 方法四（position、transform: translate）父元素设置position: relative，使用position: absolute，配合transform: translate()食用。 1234567891011121314151617181920212223242526272829303132.box&#123; position:absolute; top: 50%; left: 50%; -webkit-transform: translate(-50%, -50%); -ms-transform: translate(-50%, -50%); transform: translate(-50%, -50%);&#125;``` **缺点：需配合父元素食用，元素脱离文档流** ### 方法五（display: table-cell）将父元素display改成table表格的形式，再配合`vertical-align: middle`食用。 （即，以表格单元格实现居中） ```html&lt;style&gt;.box&#123; display: table; vertical-align: middle;&#125;.iBox&#123; display: table-cell; vertical-align: middle; text-align: center;&#125;&lt;/style&gt;&lt;body&gt; &lt;div class="box"&gt; &lt;div class="iBox"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 缺点：改变了父元素的display属性。IE6-7不支持display:table-cell 方法六（flex）推荐！！！flex布局（伸缩布局盒模型，也叫弹性布局盒模型） 1234567.box&#123; display: flex; align-items: center; justify-content: center; /*兼容 IE11*/ display: -ms-flex;&#125; 缺点：兼容问题，不支持IE11以下（不包括11）]]></content>
      <categories>
        <category>随手记</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[滚动条默认样式修改]]></title>
    <url>%2F2020%2F05%2F21%2F-webkit-scrollbar%2F</url>
    <content type="text"><![CDATA[浏览器默认滚动条样式修改；微信小程序隐藏滚动条 浏览器1234567891011121314151617181920/*滚动条整体部分*/::-webkit-scrollbar&#123;&#125; /*滚动条两端的按钮*/::-webkit-scrollbar-button&#123;&#125; /*外层轨道*/::-webkit-scrollbar-track&#123;&#125; /*内层轨道*/::-webkit-scrollbar-track-piece&#123;&#125; /* 滚动条拖动部分*/::-webkit-scrollbar-thumb&#123;&#125; /*边角*/::-webkit-scrollbar-corner&#123;&#125; /*右下角拖动块*/::-webkit-resizer&#123;&#125; dome 1234567891011121314151617181920212223242526/*滚动条整体*/.dome::-webkit-scrollbar &#123; width: 8px; height: 1px;&#125;.dome::-webkit-scrollbar-thumb &#123; border-radius: 8px; box-shadow: inset 0 0 5px rgba(0,0,0,0.2); background-color: #96C2F1; background-image: linear-gradient( 45deg, rgba(255, 255, 255, 0.2) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.2) 50%, rgba(255, 255, 255, 0.2) 75%, transparent 75%, transparent );&#125;.dome::-webkit-scrollbar-track &#123; box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.1); border-radius: 8px; background: #EFF7FF;&#125; 微信小程序移除滚动条 12345::-webkit-scrollbar&#123; width: 0; height: 0; color: transparent;&#125;]]></content>
      <categories>
        <category>随手记</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AssemblyScript 初次使用]]></title>
    <url>%2F2020%2F03%2F03%2FAssemblyScript%2F</url>
    <content type="text"><![CDATA[AssemblyScript 记一次AssemblyScript 的使用记录, AssemblyScript 是使用 Binaryen 将 TypeScript 编译成 WebAssembly 前言 WebAssembly 是一种接近机器语言的跨平台二进制格式。2017年3月份，四大主流浏览器厂商 Google Chrome、Apple Safari、Microsoft Edge 和 Mozilla FireFox 均宣布已经于最新版本的浏览器中支持了 WebAssembly AssemblyScript 是使用 Binaryen 将 TypeScript 编译成 WebAssembly 安装1npm i assemblyscript -D 脚手架1npx asinit . 自动生成 assembly/index.ts 入口文件 1234// The entry file of your WebAssembly module.export function add(a: i32, b: i32): i32 &#123; return a + b;&#125; build目录 编译后 wasm文件存放 编译1npm run asbuild node下使用引用脚手架会自动生成引入文件index.js 1234567const fs = require("fs");// 加载wasm模块const compiled = new WebAssembly.Module(fs.readFileSync(__dirname + "/build/optimized.wasm"));const imports = &#123;&#125;;Object.defineProperty(module, "exports", &#123; get: () =&gt; new WebAssembly.Instance(compiled, imports).exports&#125;); 使用新建个js 123const &#123; add &#125; = require('./index.js');const sum = add(1,1);console.log(sum); // node运行输出: 2 浏览器下使用引用新建个js 1234567891011121314151617181920212223242526272829303132333435363738394041// 封装 https://github.com/torch2424/wasm-by-example/blob/master/demo-util/const wasmBrowserInstantiate = async (wasmModuleUrl, importObject) =&gt; &#123; let response = undefined; if (!importObject) &#123; importObject = &#123; env: &#123; abort: () =&gt; console.log("Abort!") &#125; &#125;; &#125; // Check if the browser supports streaming instantiation if (WebAssembly.instantiateStreaming) &#123; // Fetch the module, and instantiate it as it is downloading response = await WebAssembly.instantiateStreaming( fetch(wasmModuleUrl), importObject ); &#125; else &#123; // Fallback to using fetch to download the entire module // And then instantiate the module const fetchAndInstantiateTask = async () =&gt; &#123; const wasmArrayBuffer = await fetch(wasmModuleUrl).then(response =&gt; response.arrayBuffer() ); return WebAssembly.instantiate(wasmArrayBuffer, importObject); &#125;; response = await fetchAndInstantiateTask(); &#125; return response;&#125;;// 引用let wasmModule;(async () =&gt; &#123; // Instantiate our wasm module wasmModule = await wasmBrowserInstantiate('./build/optimized.wasm'); return wasmModule;&#125;)(); 使用新建个html 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;dome&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;input type="text" id="a"&gt; &lt;span&gt;+&lt;/span&gt; &lt;input type="text" id="b"&gt; &lt;button id="btn"&gt;=&lt;/button&gt; &lt;span id="sum"&gt;?&lt;/span&gt; &lt;script src="index.js"&gt;&lt;/script&gt; &lt;script&gt; const a = document.getElementById('a'); const b = document.getElementById('b'); const sum = document.getElementById('sum'); const btn = document.getElementById('btn'); btn.addEventListener('click', click); function click() &#123; const result = wasmModule.instance.exports.add(parseFloat(a.value), parseFloat(b.value)); sum.innerText = result; &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>WebAssembly</category>
      </categories>
      <tags>
        <tag>AssemblyScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓开发——笔记（1）]]></title>
    <url>%2F2020%2F02%2F29%2FAndroid-note(1)%2F</url>
    <content type="text"><![CDATA[记录安卓开发时，所遇到的问题及方法 调试输出1234567import android.util.Log;Log.v("a", "Haha , this is a Verbose of MyAndroid. ");Log.d("a", "Haha , this is a Debug of MyAndroid. ");Log.i("a", "Haha , this is a Info of MyAndroid. ");Log.w("a", "Haha , this is a Warning of MyAndroid. ");Log.e("a", "Haha , this is a Error of MyAndroid. "); 点击事件获取文本内容1234567891011final TextView value = (TextView) findViewById(R.id.textView);Button btn = new Button(this);//绑定点击事件btn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; String text = ((Button) v).getText().toString(); value.setText(value.getText()+text); &#125;&#125;); 在xml里绑定事件并传参数xml部分代码 123&lt;Button android:onClick="click" android:tag="params"/&gt; java部分代码 123public void click(View view)&#123; String param = view.getTag().toString();&#125; 引用res里的资源，类型变为 View通过加载器 LayoutInflater 12LayoutInflater tableItem = LayoutInflater.from(this);View viewItem = tableItem.inflate(R.layout.fbutton_item, null); handler发送消息(线程间通讯)子线程里无法调用ui，通过handler发送消息至ui线程 123456789101112131415161718192021222324252627private static final int SHOW_TOAST = 1;private Handler mHandler = null; @Overridepublic void onCreate()&#123; Message msg = new Message(); msg.what = SHOW_TOAST; msg.obj = "信息"; mHandler.sendMessage(msg);&#125;// 发送消息private class MsgHandler extends Handler &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what)&#123; case SHOW_TOAST: String text = msg.obj.toString(); Toast toast = Toast.makeText(getApplicationContext(), text, Toast.LENGTH_LONG); toast.setGravity(Gravity.CENTER, 0, 0); toast.show(); break; default: throw new IllegalStateException("Unexpected value: " + msg.what); &#125; &#125;&#125; 广播事件Tip: 可一个接收器 对应多个 action ( 用 intent-filter 包裹) 或 多个接收器 1234567891011&lt;receiver android:name=".MyBroadcastReceiver" android:enabled="true" android:exported="true"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.BOOT_COMPLETED" /&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.DOWNLOAD_COMPLETE" /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 将数据写入本地缓存用 SharedPreferences 1234567891011121314private SharedPreferences sf;private SharedPreferences.Editor edit;public void onCreate() &#123; // 链接库 sf = getSharedPreferences(getResources().getString(R.string.app_name), Context.MODE_PRIVATE); // 编辑器 edit = sf.edit(); // set 值 edit.putString("key","value"); edit.commit(); // get 值 sf.getString("key","");&#125; 播放mp3音频 在main目录下 新建个 assets目录 存放mp3音频 用 MediaPlayer 播放音频 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253private MediaPlayer musicPlay = null;private AssetManager assetManager = null;private List&lt;AssetFileDescriptor&gt; musicQueue = new ArrayList&lt;AssetFileDescriptor&gt;();// 初始化播放器private void initPlayer(Context context) &#123; // 获取asset文件管理器 assetManager = context.getAssets(); // new 播放器 musicPlay = new MediaPlayer(); // 播放结束监听 musicPlay.setOnCompletionListener(new MediaPlayer.OnCompletionListener() &#123; @Override public void onCompletion(MediaPlayer mp) &#123; // 存在播放队列 if (musicQueue.size() != 0) &#123; play(musicQueue.get(0)); musicQueue.remove(0); &#125; return; &#125; &#125;);&#125;// 开始播放private void play(AssetFileDescriptor music) &#123; try &#123; // 存在播放任务,追加队列中 if (musicPlay.isPlaying()) &#123; musicQueue.add(music); return; &#125; // 重置播放器 musicPlay.reset(); // 设置播放资源 musicPlay.setDataSource(music.getFileDescriptor(), music.getStartOffset(), music.getLength()); // 预加载 musicPlay.prepare(); // 开始 musicPlay.start(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125;// 选择播放音频private void selectMusic() &#123; try &#123; // 播放 test.mp3 this.play(assetManager.openFd("test.mp3")); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 解析JSON 用 阿里的 fastjson app 配置文件 123dependencies &#123; implementation &apos;com.alibaba:fastjson:1.2.62&apos;&#125; 简单dome 123456// 引import com.alibaba.fastjson.JSONObject;// 反序列化JSONObject data = JSONObject.parseObject(res);String type = data.getString("type"); socket123456789101112131415161718192021222324// 连接 socketsocket = new Socket(SOCKET_IP, SOCKET_PORT);//构建IOInputStream is = socket.getInputStream();OutputStream os = socket.getOutputStream();bw = new BufferedWriter(new OutputStreamWriter(os));//读取服务器返回的消息br = new BufferedReader(new InputStreamReader(is));//向服务器端发送一条消息try &#123; bw.write("msg" + "\n"); bw.flush();&#125; catch (IOException e) &#123; e.printStackTrace();&#125;// 持续读消息String res;while ((res = br.readLine()) != null) &#123; // 当读到消息 do something &#125; 弹窗AlertDialog基本用法 setTitle ：为对话框设置标题 setIcon ：为对话框设置图标 setMessage：为对话框设置内容 setView ： 给对话框设置自定义样式 setItems ：设置对话框要显示的一个list，一般用于显示几个命令时 setMultiChoiceItems ：用来设置对话框显示一系列的复选框 setSingleChoiceItems ：用来设置对话框显示一系列的单选框 setNeutralButton ：普通按钮 setPositiveButton ：给对话框添加”Yes”按钮 setNegativeButton ：对话框添加”No”按钮 create ： 创建对话框 show ：显示对话框 dome 12345678910111213AlertDialog.Builder builder = new AlertDialog.Builder(this);builder.setTitle("这是标题") .setMessage("这是内容") .setNegativeButton("取消", null) .create();builder.setPositiveButton("确定", new DialogInterface.OnClickListener() &#123; public void onClick(DialogInterface dialog, int which) &#123; // do something &#125;&#125;);builder.show(); 打开跳转至无障碍设置页面123Intent intent = new Intent(Settings.ACTION_ACCESSIBILITY_SETTINGS);intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);this.getApplicationContext().startActivity(intent); 通过shell静默开启无障碍模式 root权限 开启 12345678910111213141516// 包名/程序名String myAs = this.getPackageName() + "/" + MainAccessibilityService.class.getName();// 获取目前设置无障碍模式的appString nowAs = shellExec("settings get secure enabled_accessibility_services");nowAs.replace("\n", "");// 目前存在其它时,追加 : 隔开if (nowAs.length() &gt; 1 &amp;&amp; !nowAs.contains(myAs)) &#123; nowAs = ":" + nowAs;&#125;// 不存在时,即设置.存在直接启动if(!nowAs.contains(myAs))&#123; String cmd = "settings put secure enabled_accessibility_services " + myAs + nowAs; shellExec(cmd);&#125;// 启动shellExec("settings put secure accessibility_enabled 1"); 关闭 12345678910111213141516171819202122232425262728// 包名/程序名String myAs = this.getPackageName() + "/" + MainAccessibilityService.class.getName();// 获取目前的配置String nowAs = shellExec("settings get secure enabled_accessibility_services");nowAs.replace("\n", "");// 找到需关闭的程序对应下标int index = nowAs.indexOf(myAs);// 找到后if (index &gt;= 0) &#123; // 前面的 : 下标 int beforeIndex = nowAs.lastIndexOf(":", index); // 后面的 : 下标 int afterIndex = nowAs.indexOf(":", index); // 判断下,得到 需关闭程序+: 的头尾 下标 if (beforeIndex &lt; 0) beforeIndex = 0; if (afterIndex &lt; 0) afterIndex = nowAs.length(); else afterIndex++; // 截取 String As = nowAs.substring(0, beforeIndex) + nowAs.substring(afterIndex, nowAs.length()); // 判断是否为空 if (As.length() &gt; 0) &#123; shellExec("settings put secure enabled_accessibility_services " + As); shellExec("settings put secure accessibility_enabled 1"); &#125; else &#123; shellExec("settings put secure enabled_accessibility_services ''"); shellExec("settings put secure accessibility_enabled 0"); &#125;&#125; 执行shell 命令简易版 123456789101112131415161718192021222324252627282930313233343536373839private String shellExec(String cmd) &#123; StringBuilder result = new StringBuilder(); try &#123;// Log.i(Tag, "start shell command"); Runtime runtime = Runtime.getRuntime(); Process process = runtime.exec("su"); DataOutputStream os = new DataOutputStream(process.getOutputStream()); os.write(cmd.getBytes()); os.writeBytes("\n"); os.flush(); os.writeBytes("exit\n"); os.flush(); BufferedReader successResult = new BufferedReader(new InputStreamReader(process.getInputStream())); BufferedReader errorResult = new BufferedReader(new InputStreamReader(process.getErrorStream())); String str; while ((str = errorResult.readLine()) != null) &#123; result.append(str + "\n"); &#125; while ((str = successResult.readLine()) != null) &#123; result.append(str + "\n"); &#125;// Log.i(Tag, result.toString());// Log.i(Tag, "end shell"); os.close(); successResult.close(); errorResult.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return result.toString(); &#125; 静默安装apk root 权限 su 下执行 1234// shell 运行命令shellExec("pm install xxx/xxx.apk");// 覆盖安装shellExec("pm install -r xxx/xxx.apk"); 调用系统安装apk (需手动点击安装)123456789101112// 安装路径String path = "xxx/xxx.apk";File file = new File(path);// 是否存在if(file.exists())&#123; Uri fileUri = Uri.fromFile(file); // 执行安装 Intent installIntent = new Intent(Intent.ACTION_VIEW); installIntent.setDataAndType(fileUri, "application/vnd.android.package-archive"); installIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); this.startActivity(installIntent);&#125; Tip 字体单位 用 sp 常用单位dp]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓adb调试]]></title>
    <url>%2F2020%2F02%2F21%2FAndroid-adb%2F</url>
    <content type="text"><![CDATA[安卓adb调试常用adb命令记录 通过局域网连接设备1234cd Androidcd Sdkcd platform-toolsadb.exe connect xxx.xxx.xxx.xxx 安装apk1adb.exe -s 设备 install apk路径 覆盖安装1adb.exe -s 设备 install -r apk路径 卸载apk1234adb -s 设备 uninstall apk路径# oradb shell pm uninstall 包名 重启设备1adb reboot 从设备下载文件前提：adb连接上设备 1adb pull 设备文件路径 下载到本地路径 e.g 1adb pull /data/logs/ D:/log/ 上传文件至设备前提：adb连接上设备 1adb push 本地文件路径 设备路径 e.g 1adb push D:/log/ /data/logs/ 查看连接的设备列表1adb devices -l 启动连接设备上的App应用1234adb shell am start -n 包名/Activity类目# e.g# adb shell am start -n com.example.test/com.example.test.MainActivity]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓app开机启动]]></title>
    <url>%2F2020%2F02%2F01%2Fandroid-AppStartRun%2F</url>
    <content type="text"><![CDATA[实现app开发，开机自启app，简易教程 安卓app开机启动项目需求要实现，程序随手机开机启动 实现原理: Android系统在开机时，会向所有app发起广播，通知app已经开机了。因此，只需要接受拦截到这个广播就能实现开机自启。 步骤一 打开全局配置文件AndroidManifest.xml 添加 android:installLocation=&quot;internalOnly&quot;将app安装在内存中，安装在sd卡不知道会不会影响广播信息的接受（暂时未验证） 添加开机自启权限&lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot; /&gt; 在&lt;application&gt;&lt;/application&gt;中添加，注册系统广播信息接受者 123456789&lt;receiver android:name=".MyBroadcastReceiver" android:enabled="true" android:exported="true"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.BOOT_COMPLETED" /&gt; &lt;category android:name="android.intent.category.HOME" /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 步骤二 在java/com.example.包名中，新建MyBroadcastReceiverjava程序 添加接受广播信息的处理方法onReceive 12345678910111213141516171819202122232425262728293031package com.example.包名;import android.content.BroadcastReceiver;import android.content.Context;import android.content.Intent;import android.widget.Toast;public class MyBroadcastReceiver extends BroadcastReceiver &#123; private final String ACTION_BOOT = "android.intent.action.BOOT_COMPLETED"; /** * 接收广播消息后都会进入 onReceive 方法，然后要做的就是对相应的消息做出相应的处理 * * @param context 表示广播接收器所运行的上下文 * @param intent 表示广播接收器收到的Intent */ @Override public void onReceive(Context context, Intent intent) &#123; /* * 如果 系统 启动的消息，则启动 APP 主页活动 */ if (ACTION_BOOT.equals(intent.getAction())) &#123; Intent i = new Intent(context, MainActivity.class); i.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); context.startActivity(i); Toast.makeText(context,"唤醒成功",Toast.LENGTH_LONG).show(); &#125; &#125;&#125; 注意事项 手机设置问题手机管家之类的程序可能会阻止app程序开机自启动 第一次安装app后，需手动启动，后续即可自启动 Android中规定了BroadCastReceiver不能处理复杂长时间的逻辑操作，如果在onReceive方法在10s内没法执行完毕，则系统会视之为未响应状态，可能会报ANR错误。可以将这些耗时操作放在Service中开辟子线程去执行。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓串口通讯（模拟机测试）]]></title>
    <url>%2F2020%2F01%2F15%2Fandroid-serialPort%2F</url>
    <content type="text"><![CDATA[安卓串口通讯Android studio模拟机模拟测试串口通讯，踩坑记录 Android 串口需求安卓通过串口与硬件设备通讯交互 开源的 android_serialport_api库 需要 Android studio 模拟机 不要下带Play Store(谷歌商店) ，会获取不到root权限的 虚拟串口设备工具 下载安装后，虚拟对 串口 COM1-COM2 (其他的也行，本文用COM1-COM2为例) 本文使用Virtual Serial Port Driver Pro 9.0 串口调试工具 网上随便找个，能测试收发就行 本文使用 Serial Port Utility 步骤零 串口调试工具 启动打开 COM1口，波特率 9600 (两端一致就行) 模拟机 安装完后，打开命令提示符cmd 进入你 Android studiosdk 所安装的位置 ,里面的 tools 例如 D:\Android\Sdk\tools 执行 1emulator.exe @api -qemu -serial COM2 COM2 是要映射的端口 api 是我的模拟器 名字 不知道的可用下列命令查看 1emulator.exe -list-avds 执行成功后，会让你选配置，同串口工具一致即可 模拟器开机后，需设置串口权限 进入 D:\Android\Sdk\platform-tools 执行 12345678 # 进入 Android 内部 adb.exe shell# 切换至 管理员权限 su # 打开 串口 所有权限 chmod 777 /dev/ttyS1 # 关闭校验 setenforce 0 以上两端联通 大致对应表 ttyS0 — COM1 ttyS1 — COM2 注意: 模拟器的 COM1 口 好像被占用了 步骤一copy android_serialport_api的文件 jni目录(文件夹以及里面全部内容) jniLibs目录(文件夹以及里面全部内容) android_serialport_api目录(文件夹以及里面全部内容) 步骤二 jni和jniLibs 移动至自己项目里的app&gt;src&gt;main下 android_serialport_api 放到 java 移动完成后，用studio 预览下看是否添加成功 步骤三现在开始使用 /dev/ttyS1 对应 COM2 (模拟器上的) 1234567891011121314151617181920212223242526//引入库import android_serialport_api.SerialPort;/*** 省略不重要代码**/private void serialport ()&#123; //打开串口 ttyS1 SerialPort mSerialPort = new SerialPort(new File("/dev/ttyS1"), 9600, 0); // 输出流 OutputStream mOutputStream = mSerialPort.getOutputStream(); // 输入流 InputStream mInputStream = mSerialPort.getInputStream(); //发送信息 byte[] send_msg = new byte[1]; send_msg[0] = new String("100").byteValue(); mOutputStream.write(send_msg); mOutputStream.flush(); //接收信息 byte[] get_msg = new byte[1]; int size = mInputStream.read(get_msg); String msg = Integer.valueOf(get_msg[0]).toString();&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mpvue 踩坑历程]]></title>
    <url>%2F2019%2F09%2F16%2Fmpvue%2F</url>
    <content type="text"><![CDATA[开发微信小程序，但迫于原生开发对开发者的不友好，于是使用基于vue开发的mpvue框架开发微信小程序。本文是用于记录本人在使用mpvue时所踩的坑，以及一些经验之谈。 前言 本文用的是 npm下载慢？ 点这解决介绍mpvue 是美团开发的一个使用 Vue.js 开发小程序的前端开源框架。框架基于 Vue.js 核心，mpvue 修改了 Vue.js 的 runtime 和 compiler 实现，使其可以运行在小程序环境中，从而为小程序开发引入了整套 Vue.js 开发体验。 fork 自 vuejs/vue@2.4.1，保留了 vue runtime 能力 mpvue特性 彻底的组件化开发能力：提高代码复用性 完整的 Vue.js 开发体验 方便的 Vuex 数据管理方案：方便构建复杂应用 快捷的 webpack 构建机制：自定义构建策略、开发阶段 hotReload(热更新) 支持使用 npm 外部依赖 使用 Vue.js 命令行工具 vue-cli 快速初始化项目 H5 代码转换编译成小程序目标代码的能力 支持平台 微信小程序 百度小程序 支付宝小程序 头条小程序 h5 开始安装环境需 调试需要对应平台的开发者工具 1234567891011#安装npm install -g vue-cli@2.9#创建vue init mpvue/mpvue-quickstart myApp#依赖cd myAppnpm install#运行npm run devnpm run build new Page需按特定的格式命名文件(参考现有的文件),以及得在app.json里配置相应路径自定义的话，也可以，不过要改的地方有点多main.js、webpack配置也要改 e.g: pageA index.vue main.js(写法固定) main.json(官方建议要有，个人感觉可无) 将app.json/page.json写在***.vue里v2.0版本，官方建议app.json/page.json另起一个文件，还要维护多一个文件好麻烦啊，直接写在vue里得了用webpack处理下 1npm install --save-dev mpvue-config-loader 修改build/webpack.base.conf.js文件 1234567891011//module里追加rules，大概在60行左右//将js部分的 config字段转化成相应的json文件&#123; test: /\.vue$/, loader: 'mpvue-config-loader', exclude: [resolve('src/components')], options: &#123; entry: './main.js' &#125;&#125;, 使用 方式一：可自行生成app.json/main.json 方式二：在.vue里 12345export default&#123; config:&#123; "navigationBarTitleText": "练习" &#125;&#125; 注意：两种方式只能选其一，不然会发生覆盖错误 引入sass1234npm install node-sass sass-loader --save#全局使用sass变量(选装)npm install sass-resources-loader --save 修改webpack配置(使用全局sass时需修改，不使用就不用)1234567//build/utils.js文件，大约70行左右scss: generateLoaders('sass').concat(&#123; loader:'sass-resources-loader', options:&#123; resources:path.resolve(__dirname,'../src/libs/base.scss') //这是全局sass的配置文件，路径可随意更改 &#125; &#125;), 使用在要使用sass的vue文件里的style标签加上lang=&#39;scss&#39; 123&lt;style lang="scss"&gt;&lt;/style&gt; Tip:注意 webpack 的版本，webpack版本过低，但安装的 sass 版本过高时可能会出错。安装时，注意报错信息就好了😂附: 本人的安装环境 “webpack”: “^3.11.0”, “node-sass”: “^4.11.0”, “sass-loader”: “^7.1.0”, “sass-resources-loader”: “^2.0.0”, 引入vuex创建模板时选择vuex，或者自行安装 1npm install vuex --save vuex的用法 同vue里一样，只是在实例中挂载可能有所区别。方式一：按需引入，在要使用的vue文件里 import 引入 12//单个vue文件里import store from './store' 方式二：全局引入，直接挂载到vue的原型链上 1234//main.jsimport store from './store'Vue.prototype.$store = store 接入微信云函数步骤有四 其一: 在根目录创建个 云函数目录 e.g: cloud 其二: 修改config/index.js配置文件，大概20行左右，找到wx字段里的platform字段，将值改成platform: &#39;wx/miniprogram&#39; 123456 wx: &#123; template: 'wxml', script: 'js', style: 'wxss', platform: 'wx/miniprogram',&#125;, 其三: 修改project.config.json微信项目配置文件，新增字段cloudfunctionRoot和修改miniprogramRoot字段 1234&#123; "miniprogramRoot": "./miniprogram/", "cloudfunctionRoot": "./cloud/"&#125; 其四: 修改webpack.base.conf.jswebpack配置文件，末尾新增个if，当是微信时打包将云函数目录和config项目配置文件copy过去 12345678910111213141516171819202122232425const PLATFORM = process.env.PLATFORM;if (/^(swan)|(tt)$/.test(PLATFORM)) &#123; baseWebpackConfig = merge(baseWebpackConfig, &#123; plugins: [ new CopyWebpackPlugin([&#123; from: path.resolve(__dirname, projectConfigMap[PLATFORM]), to: path.resolve(config.build.assetsRoot) &#125;]) ] &#125;);&#125; else if ('wx' === PLATFORM) &#123; //云函数 baseWebpackConfig = merge(baseWebpackConfig, &#123; plugins: [ new CopyWebpackPlugin([&#123; from: path.resolve(__dirname, projectConfigMap.tt), to: path.resolve(__dirname, '../dist/wx/') &#125;]), new CopyWebpackPlugin([&#123; from: path.resolve(__dirname, '../apiCloud'), to: path.resolve(__dirname, '../dist/wx/cloud') &#125;]) ] &#125;);&#125; 最后: run dist/wx目录里出现cloud、miniprogram、project.config.json，就成功了 Tip: 云函数的添加方法，编译完了还是得在微信开发者工具里更新提交☹ project.config.json文件，最好将appid字段填正确，不然每次run project.config.json都会被替换，会提示appid不一致😂 坑😠生命周期同 vue，不同的是在小程序 onReady 后，再去触发 vue mounted 生命周期 同时还兼容了微信小程序的生命周期，但不建议使用 不支持 BOM／DOM 操作小程序里所有的 BOM／DOM 都不能用，也就是说 v-html 指令不能用 复杂的 JavaScript 渲染表达式可能会出问题 渲染时会把 template 中的双花括号的部分，直接编码到 wxml 文件中，由于微信小程序的能力限制(数据绑定)，所以无法支持复杂的 JavaScript 表达式 不能在 template 内使用 methods 中的函数能用计算属性computed就用计算属性吧 mpvue不支持自定义tabBar方式1: 用微信官方的自定义tabBar写个原生的tabBar，修改webpack配置，copy过去 问题： 自定义tabBar会在每个页面都存在（笑），只能用官方提供的wx.hideTabBar()隐藏，以及tabBar选中状态得在当前页面用getTabBar更改选择状态，但是好像getTabBar这个获取不到实例（不知是不是我的操作有误） 方式2：先自定义个Vue组件做tabBar，接着在app.json里新增个tabBar字段配置情况同vue组件，然后在App.vue里用wx.hideTabBar()隐藏原生的，vue组件里的tab切换全部用wx.switchTab() 问题: 底部导航栏初次切换时，会发生闪烁 mpvue不支持slot-scope，连用多个slot时都可能存在问题 组件上不支持v-show 组件嵌套存在问题简单嵌套是没问题的，太复杂的可能出错，具体标准不知道，得看脸 组件使用slot时需重新编译，并且每次更新slot的插入值也需重新编译说好的热更新呢😠 自定义组件不支持v-model 改动app.json时需重新编译说好的热更新呢😠 ios与安卓滚动动画时长不一致，微信api监听屏幕滚动触发时机不一致这个不算mpvue的坑，算了不管，记录下来，当初坑了我好久 nextTick并不是渲染完成后执行，仅仅只是个延时器（怕不是个假的吧）看了下原来官方的也是这样的 wx.nextTick() 延迟一部分操作到下一个时间片再执行。（类似于 setTimeout） mpvue页面数据与组件并不会随页面销毁而初始化页面数据只能自己手动初始化（一个一个this难道不累么） 12//建议封装挂载到全局，毕竟每次都要用Object.assign(this.$data, this.$options.data()); 组件只能自己手动销毁 获取页面传参过来的信息12//建议封装挂载到全局，毕竟每次都要用this.$root.$mp.query[name] 大部分原生的事件响应event都在event.mp.detail里 bind 和 catch 事件同时绑定时，只会触发 bind ,catch 不会被触发 事件修饰符 .stop 可以阻止冒泡，但绑多一个非冒泡事件时会失效 .once 不能用 结语 目前踩到的坑就这些，有些可能忘记了，等遇到想起来再来补充。了解更多的可以看官网文档，文档里没写？可以去issues看看 附: 个人开发时常用封装 /ibs/utils.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100export default &#123; /** * 获取页面消息参数 * @param name * 参数名 */ getQuery(name) &#123; return this.$root.$mp.query[name]; &#125;, /* 初始化data数据（由于mpvue在组件销毁时没有初始化data，需手动init） */ init() &#123; Object.assign(this.$data, this.$options.data()); &#125;, /** * 跳转页面 * @param id 文件目录的名字,如 /pages/index/main 中的 index 即时 称为 id * (页面命名得按照固定格式) * @param param 页面传递间的参数, Object * */ toPage(id, param = &#123;&#125;) &#123; if (!id) return; let str = ''; const keys = Object.keys(param); if (keys.length) &#123; str += `?`; keys.forEach(i =&gt; &#123; str += `$&#123;i&#125;=$&#123;param[i]&#125;&amp;`; &#125;); str = str.slice(0, str.length - 1); &#125; wx.navigateTo(&#123; url: `/pages/$&#123;id&#125;/main$&#123;str&#125;` &#125;); &#125;, /** * 快速显示消息框 * @param msg * 消息内容 * @param opts * 额外参数 * icon * 消息图标 默认没有 * time * 持续时间 默认1500ms * done * 文字消失时的回调 默认 false * @return Promise */ showMessage(msg, opts) &#123; const flag = msg.constructor == String || msg.constructor == Number; opts = opts || &#123;&#125;; opts.time = opts.time || 1500; wx.showToast(&#123; title: flag ? msg : '参数格式不正确', icon: opts.icon || 'none', duration: opts.time &#125;); if (opts.done) &#123; return new Promise(resolve =&gt; setTimeout(resolve, opts.time)); &#125; &#125;, /** * 显示loading * @param msg * 消息内容, 默认 '正在加载' */ showLoading(msg = '正在加载') &#123; wx.showLoading(&#123; title: msg, mask: true &#125;); &#125;, /** * 预览图片 * 图片url数组 * @param array * @param index * 数组下标,显示第几张图片,默认第一张 */ previewImage(array, index = 0) &#123; return new Promise((resolve, reject) =&gt; &#123; const url = array[index]; wx.previewImage(&#123; current: url, urls: array, success: resolve, fail: reject &#125;); &#125;); &#125;, &#125; main.js 12345678910import utils from './libs/utils';//挂载全局工具集Vue.prototype.$utils = utils;// 获取页面消息参数Vue.prototype.$getQuery = utils.getQuery;//初始化页面内dataVue.prototype.$init = utils.init;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vuex入门]]></title>
    <url>%2F2019%2F06%2F26%2Fvuex%2F</url>
    <content type="text"><![CDATA[笔记整理，记录下vuex的基本用法，看完这个就可以算是入门了 什么是VuexVuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 安装直接下载 / CDN 引用下载链接 基于 NPM 的 CDN 链接，该链接会一直指向 NPM 上发布的最新版本。您也可以通过 https://unpkg.com/vuex@2.0.0 这样的方式指定特定的版本。在 Vue 之后引入 vuex 会进行自动安装： 12&lt;script src="/path/to/vue.js"&gt;&lt;/script&gt;&lt;script src="/path/to/vuex.js"&gt;&lt;/script&gt; npm/yarn1npm install vuex --save 或者 1yarn add vuex 在一个模块化的打包系统中，您必须显式地通过 Vue.use() 来安装 Vuex： 1234import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex) 开始每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的状态 (state) state相当于vue中的data getter相当于vue中的计算属性computed mutation、action就是方法methods module如同字面上的意思模块 目录结构 12345678910111213├── App.vue├── main.js├── components│ ├── component-A.vue│ └── ...├── views│ ├── home.vue│ └── ...└── store ├── index.js # 我们组装模块并导出 store 的地方 └── modules ├── cart.js # 购物车模块 └── products.js # 产品模块 store/index.js 12345678910import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)const store = new Vuex.Store(&#123;&#125;)export default store; main.js 1234567891011import Vue from "vue";import App from "./App.vue";import store from "./store";Vue.config.productionTip = false;const app=new Vue(&#123; router, store, render: h =&gt; h(App),&#125;).$mount("#app"); State12345const store = new Vuex.Store(&#123; state:&#123; a: 1 &#125;&#125;) 外部调用 1this.$store.state.a // 1 Getter12345678910111213const store = new Vuex.Store(&#123; state:&#123; a: 1, b: 2 &#125;, getters:&#123; getA: state =&gt; state.a, ab(state)&#123; return state.a + state.b; &#125;, sum: (state) =&gt; num =&gt; state.a + num; &#125;&#125;) 外部调用 12345this.$store.getters.getA // 1this.$store.getters.ab // 3this.$store.getters.sum(10) // 11 Mutation更改 Vuex 的 store 中的状态的唯一方法是提交 mutation 1234567891011121314const store = new Vuex.Store(&#123; state:&#123; a: 1, b: 2 &#125;, mutations:&#123; setA(state,num)&#123; state.a = num; &#125;, change(state)&#123; [state.a,state.b] = [state.b,state.a]; &#125; &#125;&#125;) 外部调用 12345678this.$store.commit('change')this.$store.state.a // 2this.$store.state.b // 1this.$store.commit('setA',100)this.$store.state.a // 100 ActionAction 类似于 mutation，不同在于： Action 提交的是 mutation，而不是直接变更状态。 Action 可以包含任意异步操作。 12345678910111213141516171819202122const store = new Vuex.Store(&#123; state:&#123; a: 1, b: 2 &#125;, mutations:&#123; setA(state,num)&#123; state.a = num; &#125;, change(state)&#123; [state.a,state.b] = [state.b,state.a]; &#125; &#125;, actions:&#123; updateA(context,num)&#123; context.commit('setA',num) &#125;, change(&#123;commit&#125;)&#123; commit('change') &#125; &#125;&#125;) 外部调用 12this.$store.dispatch('updateA',100)this.$store.dispatch('change') Module每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块 12345678910111213141516171819202122const moduleA = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;, getters: &#123; ... &#125;&#125;const moduleB = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;&#125;const store = new Vuex.Store(&#123; modules: &#123; a: moduleA, b: moduleB &#125;&#125;)store.state.a // -&gt; moduleA 的状态store.state.b // -&gt; moduleB 的状态 更详细内容,请移步vuex文档此文是为了照顾只有7秒记忆的自己用的]]></content>
      <categories>
        <category>随手记</category>
      </categories>
      <tags>
        <tag>vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css加载会有什么影响]]></title>
    <url>%2F2019%2F03%2F31%2Fcss-load%2F</url>
    <content type="text"><![CDATA[结论： css 加载不会阻塞DOM树的解析 css 加载会阻塞DOM树的渲染 css 加载会阻塞后面js语句的执行 为了避免让用户看到长时间的白屏时间，应尽可能提高css加载速度优化方案： CDN加速 对css压缩 合理使用缓存（设置cache-control、expires、E-tag，不过要注意文件更新后缓存带来的问题，最常用的方法是在文件名后追加个版本号） 减少http请求数，合并css文件]]></content>
      <categories>
        <category>随手记</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css实现水平垂直居中]]></title>
    <url>%2F2019%2F03%2F29%2Fcss-center%2F</url>
    <content type="text"><![CDATA[css 实现水平垂直居中的n种方法 方式一:最常用的方法是使用height + line-height的方式，设置同样的值，配合text-align的使用，即可实现文本的水平垂直居中对齐。 12345.box&#123; height: 100px; line-height: 100px; text-align: center;&#125; 缺点：固定高度，无法实现两行文本的垂直居中对齐 方式二:使用绝对定位的方法，配合margin负值使用。可以实现元素的水平垂直居中效果。 1234567891011121314151617.box&#123; width: 100px; height: 100px; position: absolute; top: 50%; left: 50%; margin-top: -50px; margin-left: -50px;&#125;/*简化*/.Box&#123; width: 100px; height: 100px; position: absolute; top: calc(50% - 50px); left: calc(50% - 50px);&#125; 缺点：固定高度，高度无法自适应内容。元素脱离文档流。 方式三:使用绝对定位的方法，配合margin:auto使用。可以实现元素的水平垂直居中效果。 12345678.box&#123; position: absolute; margin: auto; top: 0; right: 0; bottom: 0; left: 0;&#125; 缺点：元素脱离文档流。 方式四:使用display:table-cell，将父元素的display，变成表格，再配合vertical-align:middle使用。可以实现元素的水平垂直居中效果。 12345678910111213141516&lt;style&gt; .box&#123; display: table; vertical-align: middle; &#125; .obox&#123; display: table-cell; vertical-align: middle; text-align: center; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class='box'&gt; &lt;div class='obox'&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 缺点：改变了父元素的display，因为IE6-7不支持display:table-cell，所以使用了大量的hack,而且必须有3个元素，不然不能定位。 方式五:使用display:inline-block，必须给父元素设置高度再配合vertical-align:middle使用。可以实现元素的水平垂直居中效果。 123456789101112131415&lt;style&gt; .box&#123; height: 100px; &#125; .obox&#123; display: inline-block; vertical-align: middle; text-align: center; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class='box'&gt; &lt;div class='obox'&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 缺点：多了一个标签，需要给父元素设置高度不然没参照物。而又因为IE6-7不支持display:inline-block，增加了hack。 方式六:CSS3中存在flex布局（伸缩布局盒模型，也叫弹性布局盒模型），对于flex熟悉的朋友来说，使用flex实现水平垂直居中是再简单不过的了。 当我们使父元素display: flex时，margin: auto不仅可以水平居中，也能够实现垂直居中。这是因为auto外边距会平分水平或垂直方向上的额外空间。 当然，也可以使用justify-content: center来定义弹性项目主轴的对齐方式，align-items: center来定义弹性项目侧轴的对齐方式。 12345678910.box&#123; display: flex; align-items: center; justify-content: center;&#125;/*or*/.Box&#123; display: flex; margin: auto;&#125; 缺点：兼容问题 方式七:CSS3中还新增了grid布局（网格布局） 12345.box&#123; display: grid; align-items: center; justify-content: center;&#125; 缺点：兼容问题 Tip: 什么是 CSS hack ? 由于不同厂商的浏览器，比如Internet Explorer,Safari,Mozilla Firefox,Chrome等，或者是同一浏览器的不同版本，如IE6和IE7，对CSS的解析认识不完全一样，因此会导致生成的页面效果不一样，得不到所需要的页面效果。 需要针对不同的浏览器去写不同的CSS，让它能够同时兼容不同的浏览器，能在不同的浏览器中也能得到我们想要的页面效果。 123div &#123; -webkit-background:green;/*forfirefox*/ &#125; hack 三大类 CSS属性前缀法 选择器前缀法 IE条件注释法（即HTML头部引用if IE）Hack]]></content>
      <categories>
        <category>随手记</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http、https、tcp与udp的简单了解]]></title>
    <url>%2F2019%2F03%2F29%2Fhttp-https-tcp-udp%2F</url>
    <content type="text"><![CDATA[由于被人问到http和https的区别时，自己顿时一脸懵逼，特此写文记录。 get 和 post 不同 get 参数url可见，post不可见 get 发一个包，post发两个包 get 没body只发一次，post 将一个包分两次（header和body分开）发送 http 和 https 不同 https 是 http的安全版，在http下加入ssl层，需要到ca申请证书 http 明文未加密，https加密 端口不同http 80，https 443 tcp三次握手 连接建立（SYN，SYN-ACK, ACK） 连接终止（FIN,ACK 、FIN,ACK） tcp 和 udp 不同 tcp 面向连接，udp 面向非连接 udp 可能丢包，传输不可靠，tcp 传输可靠 udp 速度 比 tcp 快 udp 适合传输大量数据，tcp 少量数据 udp 支持 1对1，1对n，n对1，n对n，tcp 只支持 1对1 udp 没控制机制，tcp 有控制机制 http1.0 和 http1.1 不同 http1.1 支持长连接、请求的流水线处理，http1.0 只有短连接 长连接 用 请求头Connection：Keep-Alive时，保持连接；Connection：close，关闭连接 http1.1 支持 身份认证、状态管理、cache缓存机制 http1.1 新增 报文头host字段 http1.1 新增 100状态码（节约带宽） http1.1 发送信息分割成多个片段，每个块附带长度，结束长度为0，避免缓冲整个信息造成过载http2.0 header 压缩 服务器推送 新的二进制格式 多路复用 性能较1.x大幅提升]]></content>
      <categories>
        <category>随手记</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm 疑难杂症收集]]></title>
    <url>%2F2019%2F03%2F26%2Fnpm-cnpm%2F</url>
    <content type="text"><![CDATA[开发中使用npm经常会遇到各种各样的问题，在此收集记录，以便后续再遇到能直接查询。 配置成 cnpmnpm 国外源速度慢切换 国内淘宝镜像源 1npm install cnpm -g --registry=https://registry.npm.taobao.org 临时使用1npm --registry https://registry.npm.taobao.org install log4js npm 说明：NPM（节点包管理器）是的NodeJS的包管理器，用于节点插件管理（包括安装，卸载，管理依赖等） 使用NPM安装插件：命令提示符执行npm install name [-g] [–save-dev] name：节点插件名称。 安装1npm install gulp-less --save-dev 常用指令 -g：全局安装。 将会安装在C：\ Users \ Administrator \ AppData \ Roaming \ npm，并且写入系统环境变量;非全局安装：将会安装在当前定位目录;全局安装可以通过命令行任何地方调用它，本地安装将安装在定位目录的node_modules文件夹下，通过要求（）调用; –save：将保存至的package.json（的package.json是的NodeJS项目配置文件） -dev;：保存至的package.json的devDependencies节点，不指定-dev将保存至依赖节点 卸载加上上面常用指令，将在卸载的同时，执行上面相反的操作e.g 12#卸载gulp-less，同时移除package.json中配置npm uninstall gulp-less --save 清除缓存1npm cache clean -f 查看配置信息1npm config list 问题记录 win下，使用npm install/cnpm install报错 环境 系统：win10家庭版 node：v12.16.3 npm：6.14.5 npm install报错信息 npm WARN tar EINVAL: invalid argument, futimenpm WARN tar EINVAL: invalid argument, futimenpm WARN tar EINVAL: invalid argument, futimenpm WARN tar EINVAL: invalid argument, futimenpm ERR! Maximum call stack size exceeded cnpm install报错信息 Install fail! Error: EISDIR: illegal operation on a directory, symlink ……. 解决方案 项目所在盘符格式为FAT32 移至 NTFS格式盘符 ，安装成功 win下，使用npm install -g 包名 报错 npm install报错信息 npm ERR! Maximum call stack size exceeded 解决方案 找到全局安装的位置，把相应包删掉，再执行安装 1234# 大致路径 C:\Users\pc\AppData\Roaming\npm\node_modules# 执行安装npm install -g 包名 -f win下，npm run 报错 报错信息 解决方案 sass版本太高，切换成低版本试试 1234# 卸载当前版本npm uninstall sass-loader# 安装8.0.0版本npm install sass-loader@8.0.0 -D win下，npm install报错 win10 64位 Python 3.9.5 解决方案 方法一：因node-gyp与当前系统版本不符，如node32位 系统64位，切换node至64位，并执行 123npm cache clean -fnpm install --global --production windows-build-toolsnpm install --global node-gyp 方法二：未配置系统环境变量python，添加配置后重试 方法三：node-sass版本与nodejs版本不支持，修改至相应版本 后记Tip: 用cnpm总是遇到奇奇怪怪的问题 改用npm换源至淘宝1npm config set registry http://registry.npm.taobao.org/ 切换会默认源1npm config set registry https://registry.npmjs.org/ 万能解决因网络导致问题的方法安装sass时，因网络导致，出现问题 使用mirror-config-china镜像 1npm install -g mirror-config-china]]></content>
      <categories>
        <category>随手记</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决开发跨域问题]]></title>
    <url>%2F2019%2F03%2F17%2FcrossDomain%2F</url>
    <content type="text"><![CDATA[解决在开发过程中遇到的跨域问题 什么是跨域？当协议、子域名、主域名、端口号中任意一个不相同时，都是不在同一域下。不同域之间相互请求资源，就算作“跨域” 解决方案方式一：在最新版 谷歌浏览器 快捷方式/启动时 上添加条启动命令 1234-disable-web-security -user-data-dir="d:\Temp"e.g:目标： C:\Users\pt\AppData\Local\Google\Chrome\Application\chrome.exe -disable-web-security -user-data-dir="d:\Temp" 方式二：安装谷歌插件 Allow-Control-Allow-Origin: * 方式三：后端添加请求头 123Access-Control-Allow-MethodsAccess-Control-Allow-OriginAccess-Control-Allow-Headers 方式四：配置代理，如nginx 方式五：jsonp 服务器需要改动代码进行支持 只支持GET方法 发送的不是xhr请求，不支持异步方法]]></content>
      <categories>
        <category>随手记</category>
      </categories>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 常用指令]]></title>
    <url>%2F2018%2F07%2F12%2Fgit%2F</url>
    <content type="text"><![CDATA[自己经常忘记git的指令，特意记录下 配置全局配置（局部只需删掉--global） 用户信息12git config --global user.name ""git config --global user.email "***@qq.com" 记住密码全局永久记住密码（局部只需删掉--global） 1git config --global credential.helper store 全局默认记住密码15分钟 1git config --global credential.helper cache 编辑全局配置文件1git config --global --edit 查看已配置项1git config --lsit 删除配置项1git config --unset user.name 全局 1git config --global --unset user.email 创建仓库先进项目的根目录 1git init 关联远程关联远程仓库地址12345678#添加git remote add -f origin http://xxx.git#删除git remote rm origin#修改git remote set-url origin http://xxxx.git 查看远程关联信息1git remote -v 添加关联多个远程仓库分多次push origin2 可自定义 1git remote add origin2 https://xxxx.xxx.git 一次push 到 多个远程仓库 1git remote set-url --add origin https://xxx.xxx.git 删除添加关联的远程仓库1git remote set-url --delete origin https://xxx.xx.git 提交代码本地12git add . #新增， ” . “ 表示全部git commit -m "*****" #描述 将本地代码提交至服务器123#git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;git push origin master #master 主分支 参数 -u将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push，这叫做simple方式，默认只推送当前分支此外，还有一种matching方式，会推送所有有对应的远程分支的本地分支。Git 2.0版本之前，默认采用matching方法，现在改为默认采用simple方式 强制提交覆盖会被枪杀的 1git push -u origin master -f 删除远程仓库分支1git push origin --delete 分支名 下载代码123#git clone &lt;项目链接&gt; git clone https://******.git 指定分支1git clone -b 分支名 https://xxxx.git 部分下载文件12345git initgit remote add -f orgin https://xxxx.gitgit config core.sparseCheckout trueecho '文件名' &gt;&gt; .git/info/sparse-checkout #（在.git/info/创建个sparse-checkout文件）git pull orgin master 更新代码服务器 → 本地 简洁版123#git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;git pull origin master 严谨版12345678#在本地新建一个temp分支，并将远程origin仓库的master分支代码下载到本地temp分支git fetch origin master:temp#把当前分支与刚下载temp分支的比较下区别git diff temp#将当前分支与刚下载temp分支合并git merge temp#删除temp分支(想保留可以不删)git branch -d temp 强制覆盖本地123git fetch --allgit reset --hard origin/mastergit pull 拉取远程分支（本地不存在）跳转 查看状态1git status 查看当前分支1git branch 查看历史版本全部1git log 显示记录和差异1git log -p 查看最近n次数1234git log -n 参数#e.g 最近10次记录git log -n 10 单行简略、图形显示1git log --onelie --graph 版本回滚1234git reset --hard HEAD^ #上一个版本就是HEAD^，上上一个版本就是HEAD^^#e.ggit reset --hard 3628164 清除缓存1git rm -r --cached . 创建/切换分支创建分支 abc 分支名 1git branch abc 创建并切换分支1git checkout -b abc 切换分支1git checkout abc 创建本地不存在，服务器存在的分支 若报fail，请先执行 pull更新下 1git checkout -b abc orgin/abc 严瑾版（推荐）1234#在本地新建一个分支，并将远程origin仓库的分支代码下载到本地分支git fetch origin 远程分支名:本地分支名#切换分支git checkout 本地分支名 合并分支将abc分支合并到当前分支 1git merge abc 合并指定分支文件将abc分支上的d.doc合并到当前分支 1git checkout abc d.doc 删除分支12345#删除abc分支git branch -d abc #强制删除abc分支git branch -D abc 比较不同分支详细差异1git diff branch1 branch2 简要1git diff branch1 branch2 --stat 指定文件差异1git diff branch1 branch2 文件路径 标签新建标签1git tag -a 标签名 -m '描述' 删除标签本地 1git tag -d 标签名 远程 123git push origin --delete 标签名#git push origin :refs/tags/标签名 查看本地标签1234git tag#详情git show 标签名 上传标签至远程服务器1git push origin 标签名 创建一个空分支常规创建分支会包含当前的提交历史记录，下面方法创建的分支 不继承任务提交记录 无父节点 123456789101112#生成(新分支会有当前的所有文件，但记录为空)git checkout --orphan 分支名#删除全部内容（手动删除也可行）git rm -rf .#首次提交（无内容无法提交）git add .git commit -m '描述'#查看分支，现在可以看到新建的分支git branch]]></content>
      <categories>
        <category>随手记</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对js中的Primise自己的理解]]></title>
    <url>%2F2018%2F05%2F23%2Fjs-promise%2F</url>
    <content type="text"><![CDATA[对于js中的Primise自己的理解记录成笔记。JavaScript语言的执行环境是“单线程”，所谓单线程，就是一次只能够执行一个任务，如果有多个任务的话就要排队，前面一个任务完成后才可以继续下一个任务. 前言JavaScript语言的执行环境是“单线程”，所谓单线程，就是一次只能够执行一个任务，如果有多个任务的话就要排队，前面一个任务完成后才可以继续下一个任务.这种“单线程”的好处就是实现起来比较简单，容易操作；坏处就是容易造成阻塞，因为队列中如果有一个任务耗时比较长，那么后面的任务都无法快速执行，或导致页面卡在某个状态上，给用户的体验很差。一直以来，JavaScript处理异步都是以callback的方式，js中的Promise规范因而顺势而出。 状态Promise有以下几种状态: pending: 初始状态, 初始状态，未完成或拒绝。 fulfilled: 意味着操作成功完成。 rejected: 意味着操作失败。 API Promise.resolve() 执行成功 Promise.reject() 执行失败 Promise.prototype.then() 递延处理 Promise.prototype.catch() 异常 Promise.all() 所有的完成 Promise.all方法常被用于处理多个promise对象的状态集合 then()then() 方法返回一个Promise。它最多需要有两个参数：Promise的成功和失败情况的回调函数 catch()catch() 方法捕获Promise执行时出现的错误 特性 立即执行性 1234567891011121314let p=new Promise(function(resolve,reject)&#123; console.log("create new promise"); resolve("success"); &#125;); console.log("after new promise"); p.then(function(value)&#123; console.log(value); &#125;); //输出： //create new promise //after new promise //success 状态不可逆性、链式调用 12345678910111213141516171819202122232425 var p = new Promise(function(resolve, reject)&#123; resolve(1); &#125;); p.then(function(value)&#123; //第一个then console.log(value); return value*2; &#125;).then(function(value)&#123; //第二个then console.log(value); &#125;).then(function(value)&#123; //第三个then console.log(value); return Promise.resolve('resolve'); &#125;).then(function(value)&#123; //第四个then console.log(value); return Promise.reject('reject'); &#125;).then(function(value)&#123; //第五个then console.log('resolve: '+ value); &#125;, function(err)&#123; console.log('reject: ' + err); &#125;) //输出： //1 //2 //undefined //resolve //reject: reject then() 回调异步性 123456789101112 var p = new Promise(function(resolve, reject)&#123; resolve("success"); &#125;); p.then(function(value)&#123; console.log(value); &#125;); console.log("first"); //输出： //"first" //"success" dome12345678910111213141516//1.先新建一个promiselet p = new Promise((resolve,reject)=&gt;&#123;//模拟异步操作 setTimeout(()=&gt;&#123; resolve('success'); reject('error'); &#125;,5000)&#125;)//2.then()//res即为 resolve回调的‘success’ ; err即为 reject回调的‘error’p.then(res=&gt;&#123; console.log(res);&#125;).catch(err=&gt;&#123; console.log(err);&#125;)]]></content>
      <categories>
        <category>随手记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>primise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js中Date的常用方法]]></title>
    <url>%2F2017%2F09%2F13%2Fjs-Date%2F</url>
    <content type="text"><![CDATA[学习记录 - js Date 获取当前时间的方法方式一： 1new Date(); //Wed Sep 13 2017 23:59:59 GMT+0800 (中国标准时间) 方式二：（以毫秒的形式） 1Date.now(); //1566310835187 get API获取指定时间内的部分数值（如：年、月、日） 不指定时间，默认当前时间 12345678910111213141516const date = new Date('1566310835187'); //获取指定时间// const date = new Date();//获取当前时间//年(4位数)date.getFullYear(); //2017//月(0-11)date.getMonth(); //8//日(1-31)date.getDate(); //13//时date.getHours(); //23//分date.getMinutes(); //59//秒date.getSeconds(); //59//毫秒date.getMilliseconds(); //747 set API12345678910111213141516//获取当前时间const date = new Date();//年(4位数)date.setFullYear(2017); //月(0-11)date.setMonth(8); //日(1-31)date.setDate(13); //时date.setHours(23); //分date.setMinutes(59); //秒date.setSeconds(59); //毫秒date.setMilliseconds(747); 其他 API .toString 将当前时间转成字符串类型 .toDateString 日期部分以字符串显示 .toTimeString 时间部分以字符串显示 .toLocaleString 以本地的时间格式显示当前时间 .toLoacleTimeString 以本地时间格式显示当前时间的时间部分 .toLocaleDateString 以本地时间格式显示当前时间的日期部分 .toUTCString 将当日的日期（根据 UTC）转换为字符串 .getTime 返回从 1970 年 1 月 1 日至今的毫秒数 .setTime 设置从1970年1月1日至今的毫秒数 注意: 在get和set后加UTC,可以获取utc时间(cookie过期时间请用utc时间避免时差导致不能准时失效) Tip Date.now();获取当前时间相对于1970年过去多少毫秒 Date.parse(&#39;2017/09/13&#39;) 生成指定格式日期距1970年过去了多少毫秒 GMT 格林威治标准时,’天文学事件’ UTC 事件,协调世界时,’原子物理事件’,他更加精确,基本不会产生误差 时区: 克服时间上的混乱,1884年在华盛顿召开的国际经度会议(国际子午线会议) 规定全球划分为24个时区,规定英国(格林威治)为0时区,分东1-12区,西1-12区,每个时区的经度宽度是15度,时差刚好是一个小时 时间戳 unix Time 纪元时间 相对于1970-1-1过去了多少秒 定时器和延时器Tip: 定时器/延时器用完记得清除，不然可能会造成内存泄漏 123456789101112131415let fn = ()=&gt;&#123; console.log('Hello')&#125;//延时器//200毫秒后调用该fn函数(只执行一次),返回一个id表示let timerId1 = setTimeout(fn,200) //清除指定id标识的延迟操作clearTimeout(timerId1) //延迟定时器方法的执行时异步的,所以计时器并不能准时调用//定时器//每200毫秒调用该fn函数(执行一次),返回一个id表示let timerId2 = setInterval(fn,200) // 清除指定id标识的计时器clearInterval(timerId2)]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js中对象Object的常用方法]]></title>
    <url>%2F2017%2F09%2F12%2Fjs-object%2F</url>
    <content type="text"><![CDATA[学习记录 - Object的常用方法 属性名表达式123456789101112// 方法一obj.foo = true;// 方法二obj['a' + 'bc'] = 123;//ES6let propKey = 'foo';let obj = &#123; [propKey]: true, ['a' + 'bc']: 123&#125;; 对象里函数 函数的name属性，返回函数名。对象方法也是函数，因此也有name属性 属性的遍历 for…in… Object.keys(obj) Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名 Object.getOwnPropertyNames(obj) Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名 Object.getOwnPropertySymbols(obj) Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性的键名 Reflect.ownKeys(obj) Reflect.ownKeys返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举 以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。 首先遍历所有数值键，按照数值升序排列。 其次遍历所有字符串键，按照加入时间升序排列。 最后遍历所有 Symbol 键，按照加入时间升序排列。 super关键字​ this关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字super，指向当前对象的原型对象 12345678910111213const proto = &#123; foo: 'hello'&#125;;const obj = &#123; foo: 'world', find() &#123; return super.foo; &#125;&#125;;Object.setPrototypeOf(obj, proto);obj.find() // "hello" 常用方法123Object.keys(obj) //返回键名数组（es6）Object.values(obj) //返回键值数组（es7）Object.entries(obj) //返回键值对数组（es7） 判断是否存在某键值hasOwnProperty() 方法会返回一个布尔值 所有继承了 Object 的对象都会继承到 hasOwnProperty 方法 12345678910111213const dome = &#123; a: 1, c: 3, warn: null, WARN: undefined&#125;;dome.hasOwnProperty('a'); // truedome.hasOwnProperty('b'); // false// Tipdome.hasOwnProperty('warn'); // truedome.hasOwnProperty('WARN'); // trueObject.prototype.hasOwnProperty.call(dome, 'a'); // true]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js中字符串String的常用方法]]></title>
    <url>%2F2017%2F09%2F12%2Fjs-string%2F</url>
    <content type="text"><![CDATA[学习记录 - String的常用方法 Tip: 全部方法均 不会改变原StringcharAt(） ​ 返回当前下标的内容 ​ 可负值 -1为最后一个 indexOf（） ​ 检索内容返回当前内容的下标 ​ 仅一次 ​ 从左往右 开始索引 ​ 可选 第二个参数 为开始的位置 lastIndexOf（） ​ 检索内容返回当前内容的下标 ​ 仅一次 ​ 从右往左 ​ 可选 第二个参数 为开始的位置 replace（x，y） ​ 用y替换x ​ 仅一次 split ​ 按参数分割字符串 ​ 返回数组 substring ​ 截取 两下标之间的字符 ​ 包含start 不包含end ​ 返回截取部分 1str.substring(index,index) slice ​ 截取 ​ 包含start 不包含end ​ 返回截取部分 1str.slice(index,index) substr ​ 截取 ​ 第二个参数 表示长度length ​ 返回截取的部分 1str.substr(index,length) toLowerCase ​ 字符串全以小写形式表示 toUpperCase ​ 字符串全以大写形式表示 length ​ 字符串的长度 concat ​ 将b字符串接到a字符串后面 toLocaleLowerCase ​ 全以小写形式表示 toLocaleUpperCase ​ 全以大写形式表示 trim ​ 去掉首尾的空格 startsWith 检测字符串是否以指定的字符开始 返回 true or false 对大小写敏感 123const str = 'lecoler.github.io';str.startsWith('lecoler') // truestr.startsWith('github') //false endsWith 检测字符串是否以指定的字符结尾 返回 true or false 对大小写敏感 123const str = 'lecoler.github.io';str.endsWith('io') // truestr.endsWith('github') //false]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js中数组Array常用方法]]></title>
    <url>%2F2017%2F09%2F12%2Fjs-array%2F</url>
    <content type="text"><![CDATA[学习记录 - Array的常用方法 pop 删除并返回最后一项 改变原数组 push 添加一项或多项到数组尾部 返回新数组的长度 改原数组 shift 删除并返回第一项 改原数组 unshift 添加并返回第一项 改变原数组 splice 添加、替换、删除数组中的项 第一个参数为开始添加、删除的下标 第二个参数为删除多少项 0 为不删除 第三个参数 可选 添加、替换的内容 返回删除的项的值 以数组形式 改变原数组 1arr.splice(index,number,content) sort 无参数 将数组按首字符排序 若参数为函数 可按函数要求排序 改变原数组 123456arr.sort(function (a,b)&#123; //从小到大排序 return a-b;&#125;)arr.sort(function (a,b)&#123; //从大到小排序 return b-a;&#125;) reverse 颠倒 将数组从右往左重新排序 返回颠倒的数组 不改原数组 slice 截取 两个下标间的内容 包含start 不包含end 返回截取内容 不会修改原数组 1arr.slice(index,index) toString 将数组转换成字符串输出 join 将数组的每项以参数连接 不写默认 ， 隔开 concat 将b数组连接到a数组后面 1a.concat(b) some 当数组中存在满足指定条件的项时 返回 true 否则 返回 false 123arr.some(function(item,index,array)&#123; //item:项,index:下标,array:数组 return item &gt; 10; //有一个满足则返回true 否则false&#125;) every 当数组中全部项都满足指定条件时 返回 true 否则 返回 false12//item:项,index:下标,array:数组arr.every((item,index,array)=&gt; item &gt; 10) //全部满足则返回true 否则false filter 检测数组中的每一项 返回 符合条件的项 以数组形式 否则 返回 空数组 不改变原数组123let arr = [1,2,3,4,99];arr = arr.filter((item,index,array)=&gt; item &gt; 10);console.log(arr); // [99] map 对数组的每一项进行指定的操作 返回 结果 以数组的形式 可遍历数组12//遍历当前数组,生成新数组arr.map((item,idx,arr)=&gt; item + 'hello world') forEach 对数组的每一项进行指定的操作 可遍历数组 返回 undefined1234//遍历数组arr.forEach( (item,idx,arr)=&gt; &#123; console.log(item,idx,arr)&#125;) new Array（） 构建新数组12let xxx = new Array();let xx = []; 遍历数组方法 for循环 / while 循环 for…in…循环 for…of…. ECMAScript512345678arr.forEach(function (item,idx,arr) &#123; //遍历数组 console.log(item,idx,arr)&#125;);arr.map(function (item,idx,arr) &#123; //遍历当前数组,生成新数组 console.log(item,idx,arr); return item + 'hello world' &#125;); Array.from( ) 将类似数组的对象转为数组 123456789let arrayLike = &#123; 0: 'tom', 1: '65', 2: '男', 3: ['jane','john','Mary'], 'length': 4&#125;;let arr = Array.from(arrayLike);console.log(arr) // ['tom','65','男',['jane','john','Mary']] 将一个类数组对象转换为一个真正的数组，必须具备以下条件： 1、该类数组对象必须具有length属性，用于指定数组的长度。如果没有length属性，那么转换后的数组是一个空数组。 2、该类数组对象的属性名必须为数值型或字符串型的数字 ps: 该类数组对象的属性名可以加引号，也可以不加引号]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js 基础]]></title>
    <url>%2F2017%2F09%2F12%2Fjs%2F</url>
    <content type="text"><![CDATA[学习记录 - js基础 划重点 js分两大类数据 基本类型(栈内存)【分别占有固定内存；用完即弃】 Number String null Boolean undefined 堆的引用地址（指针） 引用类型(堆内存)【引用地址内存固定大小，但值不定；坐等垃圾回收】 Object Function Array js中内存是自动管理的，不可见。声明变量、方法时会占用一定内存 js有垃圾回收机制 垃圾回收机制是为了以防内存泄漏（内存泄漏就是当已经不需要某块内存时这块内存还存在着） 全局变量引起的内存泄露（全局变量不会被回收）【解决：用严格模式】 闭包引起（活动对象被引用，导致闭包内变量无法回收释放）【解决：活动对象set null】 被删除DOM元素的引用（DOM被删除但对象中引用还在）【解决：对象set null】 定时器未清空、无限回调（定时器内部实现闭包，回调也是闭包）【解决：clearInterval、set null】 原理：周期性查找不再被使用的变量（根无法访问，没被引用），然后回收释放占用的内存 方式： 标记清除 当变量进入作用域（环境）时，被标记为’进入‘，离开时被标记’离开‘。’离开‘标记的将会被回收 一些优化 分代回收——新的死的快，老的活的久 增量回收——量大时分多部分标记回收，需额外标记，存在微小延迟 空闲时间收集——CPU有空才工作 引用计数（低版本的浏览器） 当变量声明并赋值引用类型时，次数+1，当此变量重新赋值时，次数-1，值=0时会被回收 js的闭包 闭包是一个拥有许多变量和绑定了这些变量的环境的表达式(通常是一个函数)，因而这些变量也是该表达式的一部分。简单来说，闭包是为了局部变量能一直活着，不被回收，同时可被外部访问 方法alert 警告框 在文档加载前弹出 confirm 确认框 确认时返回true 取消时返回false prompt 输入框 输入的所有内容均为String 不输人返回空字符串 console.log 在控制台输出参数 同类有 .error / .info 等等 var 声明变量 不建议使用，用let代替，详情见 js es6 function 声明函数 typeof 返回参数的数据类型 string number boolean underfined …. isNaN 判断参数是否NaN（NaN：Number中的不正常表现） 数学方法 MathMath.round(x)四舍五入 Math.abs(x) 绝对值 Math.ceil(x) 向上取整 Math.floor(x) 向下取整 Math.max(x,y) 最大值 Math.min(x,y) 最小值 Math.pow(x,y) x的y次幂 Math.random() 随机数 0-1（不包括1 包括0） 数据转换number1234567Number('1')// 可以转换成数字则返回数字否则返回NaN// 出现小数会保留小数// 内容为空则转换为0 1234567parseInt('13.3')// 出现小数会直接取整而不是四舍五入// 如果第一个是数字，会转换到遇到非数字为止// 内容为空则返回NaN 1234567parseFloat('13.3')// 出现小数保留小数// 如果第一个是数字会转换到遇到非数字为止// 内容为空则返回NaN string1234let num = 12String(num) // '12'num.toString() // '12' null和undefined没有该方法boolean只有“”、undefined、NaN、false、0、null会转换成false 1Boolean() // false 逻辑运算符|| or或者 有真必真 &amp;&amp; and并且 有假必假 ！ not非 取反 12345//(可用作短路运算)true&amp;&amp;('执行的命令');false||('执行的命令'); 循环for 循环语句 先判断再执行 需3参数 123for(let i = 0;i&lt;10;i++)&#123; console.log(i) // 最后输出 i = : 9&#125; for…in… 遍历数组 可遍历对象，但会对象中所有方法 123for(let i in [1,2,'c',4])&#123; console.log(i); //依次输出： 1 2 'c' 4&#125; for…of… （推荐） 遍历数组/对象 123for(let i of &#123;a:1,b:2,c:'c'&#125;)&#123; console.log(i); //依次输出： 1 2 'c'&#125; do…while… 循环语句 先执行后判断 123456let i = 0;do&#123; i++;&#125;while(i&lt;5)&#123; console.log(i); //依次输出： 1 2 3 4 5&#125; while 循环语句 先判断再执行 12345let i = 0;while(i&lt;5)&#123; console.log(i); //依次输出： 0 1 2 3 4 i++;&#125; Tip：es5中数组方法的遍历循环，如forEach、map等 循环体语break 终断 跳出当前循环 continue 中断 跳过当前一次循环 循环继续不跳出 return 终断 停止当前的操作并返回值 判断if…else… 12345if(Boolean())&#123; // '命令'&#125;else&#123; // '命令'&#125; if…else if…else… 1234567if(Boolean())&#123; // '命令'&#125;else if(Boolean())&#123; //'命令'&#125;else&#123; // '命令'&#125; switch 用于根据不同的条件执行不同的动作 表达式的值会与每个case的值比较。如果匹配，则该case关联的代码会被执行 通常与break或default关键字一起使用 break关键字用于跳出switch代码块 default关键字来规定匹配不存在时做的事情 123456789101112131415switch(i)&#123; case 0: // (执行代码); break; case 1: // (执行代码); break; case 2: // (执行代码); break; //... default: // (执行代码); break;&#125; 错误处理try 测试代码块的错误try和catch一般成对出现的 catch 处理错误 throw 创建自定义错误 12345try&#123;//当代码一出现错误时,跳过代码一,执行代码二,没错则跳过代码二 // 代码一&#125;catch(err)&#123; // 代码二&#125; 123456try&#123;//当代码一出现错误时,跳过代码一,执行代码二并创建自定义错误 // 代码一 throw('自定义错误')&#125;catch(err)&#123;//err=自定义错误 // 代码二&#125; 杂七杂八arguments 存储实参的数组(为隐藏参数) ele的坐标ele.offsetLeft = style.left 若ele已定位则按style.left,反之,则按ele到documen的left ele.offsetTop = style.top 同上理 ele.offsetWidth = style.width 获取ele的宽 ele.offsetHeight = style.height 同上理 我们知道offsetTop可以获得HTML元素距离上方或外层元素的位置，style.top也是可以的，二者的区别是： 一、offsetTop返回的是数字，而style.top返回的是字符串，除了数字外还带有单位：px。 二、offsetTop只读，而style.top可读写。 三、如果没有给HTML元素指定过top样式，则style.top返回的是空字符串。 offsetLeft与style.left、offsetWidth与style.width、offsetHeight与style.height也是同样道理 ele.clientLeft 返回对象的offsetLeft属性值和到当前窗口左边的真实值之间的距离，可以理解为边框的长度 ele.clientTop 同上理 ele.clientHeight 内容可视区域的高度 ele.clientWidth 内容可视区域的宽度 ele.scrollWidth 同下理 ele.scrollHeight IE、Opera认为scrollHeight是网页内容实际高度，可以小于clientHeight。 NS、FF认为scrollHeight是网页内容高度，不过最小值是clientHeight。 ele.scrollTop 距页面的高度(滚动条) ele.scrollLeft 距页面的宽度(一般用法document.body.scrollTop) screen.height 屏幕的高度(分辨率高) screen.width 屏幕的宽度(分辨率宽) screen.availWidth 屏幕的宽度(空白空间)(还包括了未知部分,与想象中有出入) screen.availHeight 屏幕的高度(空白空间)(还包括了屏幕底部的开始菜单栏) (一般要获取屏幕的宽度用指可视区域document.documentElement.clientWidth) (一般要获取屏幕的高度用指可视区域document.documentElement.clientHeight) ele.screenLeft 返回窗口相对于屏幕的X坐标 ele.screenTop 返回窗口相对于屏幕的Y坐标 事件对象的坐标event.screenX 鼠标相对屏幕的x坐标 event.screenY 鼠标相对屏幕的x坐标 event.offsetX 鼠标相对事件源元素的x坐标 event.offsetY 鼠标相对事件源元素的y坐标 event.clientX 鼠标相对浏览器的可视窗口的x坐标(窗口坐标) event.clientY 鼠标相对浏览器的可视窗口的y坐标(窗口坐标) event.pageX 鼠标相对document文档的x坐标(文档坐标) ie不支持 event.pageY 鼠标相对document文档的y坐标(文档坐标) ie不支持]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css 基础]]></title>
    <url>%2F2017%2F09%2F09%2Fcss%2F</url>
    <content type="text"><![CDATA[学习记录 - css基础 选择器1234567891011121314151617181920212223/*标签选择器 Tagname */div&#123;&#125;/*类名选择器 .xxx */.className&#123;&#125;/*id选择器 #xxx */#idName&#123;&#125;/*通配符 * （全部） */*&#123;&#125;/*并集选择器 .xxx,.xxx (同时选择多个) */.className,#idName&#123;&#125;/*交集选择器 Tagname.xxx (精确选择到其中一个) */div.className&#123;&#125;/*后代选择器 .xxx .xxx (指定一个里面所有的) */div span&#123;&#125;/*子代选择器 .xxx&gt;.xxx （指定一个里面的第一层）*/div&gt;a&#123;&#125;/*相邻兄弟选择器 .xxx + .xxx （选择同一个老爸的跟在自己屁股后面的兄弟） *//*专业点就是 （1）紧接在另一元素后；（2）二者有相同父元素*/div+div&#123;&#125;/*兄弟选择器 .xxa ~ .xxb (选择.xxa的屁股后面的叫.xxb的兄弟)*//*专业点就是 （1）紧接在另一元素后叫指定的名；（2）二者有相同父元素*/div ～ div&#123;&#125;/*伪类选择器 详情见下文*/ Tip: 不建议嵌套过长，解析CSS需要耗费更多的时间 特殊符一般用于 content属性，也可以用于html/js 123456789/*空格 &amp;nbsp;*//*大于 &amp;gt;*//*小于 &amp;lt;*//*商标 &amp;reg;*//*版权 &amp;copy;*/ 属性字体 color 字体颜色 #00000 16进制 black rgb(0,0,0) rgba(0,0,0,0.0) font-size 字体大小 font-weight 字体粗细 bold (等于700) 加粗 bolder (等于600) normal (等于400) 默认 font-style 字体样式 italic 斜体 normal 默认 font-family 字体系列 背景 background 背景 （下列background-× 的简写） background-color 背景颜色 background-image 背景图片 url(“ “) background-repeat 背景是否平铺 no-repeat 不平铺 repeat-y 沿y轴平铺 repeat 平铺 repeat-x 沿x轴平铺 background-position(x,y) 背景图像开始的位置 center left center 10px 20px …… background-size 容器 width 宽 height 高 display 表现形式 none 不显示(不占位置，但实际是存在的) block 块级 inline-block 行内块 inline 行内 flex grid table table-cell text-indent 首字母缩进 px em 相对于当前对象内文本的字体尺寸 rem 相对于整个html % text-align 水平对齐方式 center 居中 left 左 right 右 justify 实现两端对齐文本效果 text-decoration 规定添加到文本的装饰效果 none underline 定义文本下的一条线 overline 定义文本上的一条线 line-through 定义穿过文本下的一条线 blink 定义闪烁的文本 line-height 行高 list-style 在一个声明中设置所有的列表属性 list-style-type 列表标记类型 overflow 规定当内容溢出元素框时发生的事情 hidden 隐藏 scroll 出现滚动条 auto visibility 规定元素是否可见(占位置) visible 可见 hidden 隐藏 opacity 透明度(存在兼容问题) word-break 规定自动换行 normal 默认 break-all 允许在单词内换行 keep-all 只能在半角空格或连字符处换行 transition 过渡 cursor 规定要显示的光标的类型（形状） pointer 一只手 default 默认 crosshair 十字 move 可被移动 text 文本光标 content 内容,与 :before 以及 :after 伪元素配合使用，来插入生成内容 vertical-align 基线对齐 user-select 文本是否能选中 边距 margin 外边距（下列margin-×的简写） margin-top 上外边距 margin-right 右外边距 margin-bottom 下外边距 margin-left 左外边距 padding 内边距（下列padding-×的简写） padding-top 上内边距 padding-right 右内边距 padding-bottom 下内边距 padding-left 左内边距 边框 border 边框（下列border-×的简写） border-width 边框大小 border-style 边框样式 none 无 dotted 点 dashed 虚线 solid 实线 double 双线 border-color 边框颜色 border-radius 为元素添加圆角边框 outline 边框轮廓(外边框，简写) outline-color outline-style outline-width 位置（脱离文档流） float 浮动 left right clear 规定元素的哪一侧不允许其他浮动元素（用于清除浮动） left right both 两边 none position 定位 relative 相对定位 absolute 绝对定位 fixed 固定定位 static 回归文档流 （配合定位后使用最佳） top 顶 right 右 bottom 底 left 左 z-index 设置元素的堆叠顺序 伪类 :link 选择所有未被访问的链接(仅a标签) :visited 选择所有已被访问的链接(仅a标签) :active 当您在一个链接上点击时，它就会成为活动的（激活的） :hover 用于选择鼠标指针浮动在上面的元素 :after 选择器在被选元素的内容后面插入内容 :before 选择器在被选元素的内容前面插入内容 :focus 选择器用于选取获得焦点的元素 :first-child 选择第一个子元素 :last-child 选择最后一个子元素 :nth-child(num) 选择第 num 个子元素 :nth-of-type() 选择指定的元素 :empty 选择的元素里面没有任何内容 样式优先级 !important&gt;行内样式&gt;id选择器&gt;类选择器&gt;标签选择器&gt;通配符&gt;继承（部分样式属性可继承） 默认继承 123div&#123; color: #fff !important;&#125; 1&lt;div style="color: #000"&gt;&lt;/div&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html常用标签]]></title>
    <url>%2F2017%2F09%2F08%2Fhtml%2F</url>
    <content type="text"><![CDATA[学习记录 - html标签 html head title 标题 style css标签 script javascipt标签 meta 提供有关页面的信息 link 外联标签1&lt;link rel="stylesheet" type="text/css" href="xxxx.css"&gt; - body div 块级标签 默认占一整行 一行只显示一个 p 段落标签 span 行内标签 宽高由内容决定 一行显示多个 h1 h2 h3 h4 h5 h6 标题标签 由大到小 h1最大且一个页面只有一个 br 换行标签 hr 水平线标签 b 无语义，加粗 i 无语义，倾斜 u 无语义，下划线 s 无语义，加删除线 strong 有语义，加粗 em 有语义，倾斜 del 有语义，删除线 ins 有语义，下划线 img 图像标签 a 链接标签 input (属性 placeholder 默认输入内容) text 文本输入框 password 密码框 button 按钮 submit 提交 reset 重置 hidden 隐藏域 radio 单选框 checkbox 多选框 image 图片 button 按钮标签 table 表格标签 th 行（加粗居中） tr 行 td 列 12&lt;td colspan='num'&gt; &lt;!--跨num列--&gt;&lt;td rowspan='num'&gt; &lt;!--跨num行--&gt; ul 无序列表标签 li 容器 ol 有序列表标签 li dl 自定义列表标签 dt 居左上 dd 居右下 select 下拉框选项标签 属性multiple 多行显示 option 选项 textarea 文本域标签 form 表单标签]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
</search>
